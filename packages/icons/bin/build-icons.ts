import SVGO from 'svgo';
import fs from 'fs-extra';
import path from 'path';
import toCase from 'case';
import prettier from 'prettier';
import svgoConfig from './svgo-config';

const WARNING_MESSAGE = `/* DO NOT CHANGE!*/
/* This file is automatically generated by a build step. Changes will be overwritten. */`;

const optimizer = new SVGO(svgoConfig as any);
const prettierConfig: any = {
  ...prettier.resolveConfig.sync(path.resolve('..', '..', '.prettierrc')),
  parser: 'typescript',
};

function flatten(arr1: Array<any>): Array<any> {
  return arr1.reduce(
    (acc, val) =>
      Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val),
    [],
  );
}

async function getSvgString(filePath: string) {
  const rawFileString = fs.readFileSync(filePath, 'utf8');
  const { data } = await optimizer.optimize(rawFileString);
  return data;
}

type GetComponentStringAttrs = {
  svgString: string;
  componentName: string;
};
function getComponentString({
  svgString,
  componentName,
}: GetComponentStringAttrs) {
  const componentString = `${WARNING_MESSAGE}

  import React from 'react';
  import classNames from 'classnames';
  import IconComponentType from '../types';
  
  export const ${componentName}: IconComponentType = ({Â className, ...rest }) => (
    ${svgString
      .replace(/enable-background/g, 'enableBackground')
      .replace(/clip-rule/g, 'clipRule')
      .replace(/fill-rule/g, 'fillRule')
      .replace(
        '<svg ',
        "<svg {...rest} className={classNames('entur-icon', className)} ",
      )}
  );
  export default ${componentName};
  `;
  return prettier.format(componentString, prettierConfig);
}

async function processFile(filePath: string) {
  const componentName = toCase.pascal(path.basename(filePath, '.svg')) + 'Icon';
  const outputFile = path.resolve('tmp', `${componentName}.tsx`);
  const svgString = await getSvgString(filePath);
  const iconComponent = getComponentString({
    svgString,
    componentName,
  });

  fs.outputFileSync(outputFile, iconComponent);
  return componentName;
}

async function traverse(
  currentDirectory: string,
  dirEntry?: fs.Dirent,
): Promise<any> {
  if (dirEntry && dirEntry.isFile()) {
    const componentName = await processFile(
      path.resolve(currentDirectory, dirEntry.name),
    );
    return componentName;
  }
  const dirEntryName = dirEntry ? dirEntry.name : '';
  const items = fs
    .readdirSync(path.resolve(currentDirectory, dirEntryName), {
      withFileTypes: true,
    })
    .filter(subEntry => !['.DS_Store'].includes(subEntry.name))
    .map(subEntry =>
      traverse(path.resolve(currentDirectory, dirEntryName), subEntry),
    );
  return await Promise.all(items);
}

async function run() {
  const result = await traverse('svgs');
  const flattenedResult = flatten(result);
  const fileContent = `${WARNING_MESSAGE}
  
${flattenedResult
  .map(Comp => `export { default as ${Comp} } from './${Comp}';`)
  .join('\n')}`;

  fs.writeFileSync(path.resolve('tmp', 'index.ts'), fileContent);
  console.info(`Created ${flattenedResult.length} icon components!`);
}
run();
