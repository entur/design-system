import fs from 'fs-extra';
import path from 'path';

export type Color = {
  name: string;
  color: string;
  var: string;
  rootAlias: string;
};
export type ColorMode = {
  mode: { name: string };
  color: Color[];
  number: Array<Record<string, string>>;
};
export type variableSet = {
  css: KeyValueSet;
  scss: KeyValueSet;
  less: KeyValueSet;
  js: KeyValueSet;
  mode: string;
  usesAlias: boolean;
};
export type KeyValueSet = {
  key: string;
  value: string;
  sanitizedValue?: string;
};

export function createColorSet(filePath: string) {
  const fileData = fs.readFileSync(filePath, 'utf-8');
  const colorsUnformated = JSON.parse(fileData);

  const colorsFormatedAndMappedToModes: variableSet[] = colorsUnformated.reduce(
    (allComponentColors: variableSet[], colorMode: ColorMode) => {
      const colorsFormatedForMode: variableSet[] = colorMode.color.map(
        (color: Color) => {
          const colorNameInKebabCase = toKebabCase(color.name);
          const varNameInKebabCase = toKebabCase(color.var);
          const colorModeName = colorMode.mode.name.toLowerCase();
          const usesAlias = varNameInKebabCase !== '';

          const cssVariableKey = `--${colorNameInKebabCase}`;
          const cssVariableValue = `var(--${varNameInKebabCase})`;

          const scssVariableKey = `$${colorNameInKebabCase}`;
          const scssVariableValue = `$${varNameInKebabCase}`;

          const lessVariableKey = `@${colorNameInKebabCase}`;
          const lessVariableValue = `@${varNameInKebabCase}`;

          const jsVariableKey = `${toFlattenedJSObjectKey(color.name)}`;
          const hexValue = color.color;

          return {
            css: {
              key: cssVariableKey,
              value: usesAlias ? cssVariableValue : hexValue,
            },
            scss: {
              key: scssVariableKey,
              value: usesAlias ? scssVariableValue : hexValue,
              sanitizedValue: `#{${scssVariableValue}}`,
            },
            less: {
              key: lessVariableKey,
              value: usesAlias ? lessVariableValue : hexValue,
            },
            js: { key: jsVariableKey, value: hexValue },
            mode: colorModeName,
            usesAlias: usesAlias,
          };
        },
      );

      return [...allComponentColors, ...colorsFormatedForMode];
    },
    [],
  );
  return colorsFormatedAndMappedToModes;
}

export const WARNING_TEXT = `/* DO NOT CHANGE!*/
/* This file is automatically generated from @entur/tokens! Changes will be overwritten. */`;

export function createColorsOutputString({
  colorSet,
  keyType,
  valueType,
  withColorMode,
  importFileNames,
}: {
  colorSet: variableSet[];
  keyType: 'css' | 'scss' | 'less';
  valueType: 'css' | 'scss' | 'less';
  withColorMode?: boolean;
  importFileNames?: string[];
}) {
  const needsRoot = keyType === 'css';
  const needsImport = colorSet.every(color => color.usesAlias);

  if (withColorMode) {
    if (needsImport && importFileNames) {
      const importString = createImportStatementString({
        fileNames: importFileNames,
        extension: valueType,
        includeAs: needsImport && valueType === 'scss',
      });
      const colorVariablesString = stringWithColorMode(colorSet);
      return `${importString}
      ${colorVariablesString}
      `;
    }
    return stringWithColorMode(colorSet);
  } else {
    if (needsImport && importFileNames) {
      const importString = createImportStatementString({
        fileNames: importFileNames,
        extension: valueType,
        includeAs: needsImport && valueType === 'scss',
      });
      const colorVariablesString = stringWithoutColorMode(colorSet, needsRoot);
      return `${importString}
      ${colorVariablesString}
      `;
    }
    return stringWithoutColorMode(colorSet, needsRoot);
  }

  function stringWithColorMode(colorSet: variableSet[]) {
    const outputString = `
${WARNING_TEXT}
[data-color-mode='light'],
:root {
  ${colorSet
    .filter(color => color?.mode === 'light')
    .map(color => {
      const colorKey = color[keyType].key;
      const colorValue =
        keyType === 'css' && valueType === 'scss'
          ? color[valueType].sanitizedValue
          : color[valueType].value;
      return `${colorKey}: ${colorValue};`;
    })
    .join('\n  ')}
}

[data-color-mode='dark'] {
  ${colorSet
    .filter(color => color?.mode === 'dark')
    .map(color => {
      const colorKey = color[keyType].key;
      const colorValue =
        keyType === 'css' && valueType === 'scss'
          ? color[valueType].value
          : color[valueType].sanitizedValue;
      return `${colorKey}: ${colorValue};`;
    })
    .join('\n  ')}
}
`;

    return outputString;
  }
  function stringWithoutColorMode(colorSet: variableSet[], needsRoot: boolean) {
    const outputString = `
${WARNING_TEXT}
${needsRoot ? ':root {' : ''}
${needsRoot ? '\t' : ''}${colorSet
      .map(color => {
        const colorKey = color[keyType].key;
        const colorValue =
          keyType === 'css' && valueType === 'scss'
            ? color[valueType].sanitizedValue
            : color[valueType].value;
        return `${colorKey}: ${colorValue};`;
      })
      .join(`\n${needsRoot ? '\t' : ''}`)}
${needsRoot ? '}' : ''}
  `;
    return outputString;
  }
  function createImportStatementString({
    fileNames,
    extension,
    includeAs,
  }: {
    fileNames: string[];
    extension: 'css' | 'scss' | 'less';
    includeAs?: boolean;
  }) {
    const IMPORT_SYNTAX = { css: '@import', scss: '@use', less: '@import' };
    const asStatement = includeAs ? ' as *' : '';
    const importStatements = fileNames.map(fileName => {
      const importPath = `'~@entur/tokens/dist/${fileName}.${extension}'`;
      return `${IMPORT_SYNTAX[extension]} ${importPath}${asStatement};`;
    });

    return importStatements.join('\n');
  }
}

export function outputColorsFiles({
  colorSet,
  keyType,
  valueType,
  name,
  toAllPackages = false,
}: {
  colorSet: variableSet[];
  keyType: 'css' | 'scss' | 'less';
  valueType: 'css' | 'scss' | 'less';
  name: string;
  toAllPackages?: boolean;
}) {
  let outputString = '';

  if (toAllPackages) {
    const packageNames = getAllPackageNames();
    packageNames.forEach(packageName => {
      outputString = '';
      const variablesForCurrentPackage = colorSet.filter(variable =>
        variable.scss.key.includes(`-${packageName}-`),
      );

      if (variablesForCurrentPackage.length === 0) {
        return;
      }

      if (packageName === 'travel') {
        outputString += createColorsOutputString({
          colorSet: variablesForCurrentPackage,
          keyType,
          valueType,
          withColorMode: true,
          importFileNames: ['semantic', 'transport'],
        });
      } else {
        outputString += createColorsOutputString({
          colorSet: variablesForCurrentPackage,
          keyType,
          valueType,
          withColorMode: true,
          importFileNames: ['semantic'],
        });
      }

      fs.outputFileSync(
        path.resolve(__dirname, '../../', packageName, 'src', `${name}.scss`),
        outputString,
      );
      return;
    });
    return;
  }

  switch (name) {
    case 'base':
      outputString += createColorsOutputString({
        colorSet,
        keyType,
        valueType,
        withColorMode: true,
        importFileNames: ['semantic', 'transport'],
      });
      break;
    case 'semantic':
      outputString += createColorsOutputString({
        colorSet,
        keyType,
        valueType,
        withColorMode: false,
        importFileNames: ['primitive'],
      });
      break;
    case 'data':
      outputString += createColorsOutputString({
        colorSet,
        keyType,
        valueType,
        withColorMode: true,
      });
      break;
    default:
      outputString += createColorsOutputString({
        colorSet,
        keyType,
        valueType,
        withColorMode: false,
      });
  }

  fs.outputFileSync(path.resolve('dist', `${name}.${valueType}`), outputString);
}

export function getAllPackageNames() {
  const packageNames = fs
    .readdirSync(path.resolve(__dirname, '../../../packages'), {
      withFileTypes: true,
    })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);

  return packageNames;
}

export function toKebabCase(name: string) {
  return name.replace(/\//g, '-').replace(/\s/g, '').toLowerCase();
}

export function toFlattenedJSObjectKey(name: string) {
  const nameWithoutSpacesAndDashes = name
    .toLowerCase()
    .replace(/\s(\w)/g, (_, letter) => letter.toUpperCase())
    .replace(/\-(\w)/g, (_, letter) => letter.toUpperCase());
  const nameArray = nameWithoutSpacesAndDashes.split('/');

  const nameArrayWithStringNumbers = nameArray.map(namePart => {
    if (!isNaN(Number(namePart.charAt(0)))) {
      return `_${namePart}`;
    }
    return namePart;
  });
  return nameArrayWithStringNumbers.join('.');
}
