import fs from 'fs-extra';
import path from 'path';
import { unflatten } from 'flat';
import * as prettier from 'prettier';

type Color = {
  name: string;
  color: string;
  var: string;
  rootAlias: string;
};
type ColorMode = {
  mode: { name: string };
  color: Color[];
  number: Array<Record<string, string>>;
};
type variableSet = {
  css: KeyValueSet;
  scss: KeyValueSet;
  less: KeyValueSet;
  js: KeyValueSet;
  mode: string;
  usesAlias: boolean;
};
type KeyValueSet = {
  key: string;
  value: string;
  sanitizedValue?: string;
};

const SUPPORTED_COLOR_MODES = ['light', 'dark'];

export function createColorSet(filePath: string) {
  const fileData = fs.readFileSync(filePath, 'utf-8');
  const colorsUnformated = JSON.parse(fileData);

  const colorsFormatedAndMappedToModes: variableSet[] = colorsUnformated.reduce(
    (allComponentColors: variableSet[], colorMode: ColorMode) => {
      const colorsFormatedForMode: variableSet[] = colorMode.color.map(
        (color: Color) => {
          const colorNameInKebabCase = toKebabCase(color.name);
          const varNameInKebabCase = toKebabCase(color.var);
          const hexValue = color.color;
          const colorModeName = colorMode.mode.name.toLowerCase();
          const usesAlias = varNameInKebabCase !== '';

          return {
            css: {
              key: `--${colorNameInKebabCase}`,
              value: usesAlias ? `var(--${varNameInKebabCase})` : hexValue,
            },
            scss: {
              key: `$${colorNameInKebabCase}`,
              value: usesAlias ? `$${varNameInKebabCase}` : hexValue,
              sanitizedValue: `#{$${varNameInKebabCase}}`,
            },
            less: {
              key: `@${colorNameInKebabCase}`,
              value: usesAlias ? `@${varNameInKebabCase}` : hexValue,
            },
            js: {
              key: `${
                SUPPORTED_COLOR_MODES.includes(colorModeName)
                  ? colorModeName + '.'
                  : ''
              }${toFlattenedJSObjectKey(color.name)}`,
              value: hexValue,
            },
            mode: colorModeName,
            usesAlias: usesAlias,
          };
        },
      );

      return [...allComponentColors, ...colorsFormatedForMode];
    },
    [],
  );
  return colorsFormatedAndMappedToModes;
}

const WARNING_TEXT = `/* DO NOT CHANGE!*/
/* This file is automatically generated from @entur/tokens! Changes will be overwritten. */`;

function createColorsOutputString({
  colorSet,
  keyType,
  valueType,
  withColorMode,
  importFileNames,
}: {
  colorSet: variableSet[];
  keyType: 'css' | 'scss' | 'less';
  valueType: 'css' | 'scss' | 'less';
  withColorMode?: boolean;
  importFileNames?: string[];
}) {
  const needsRoot = keyType === 'css';
  const needsImport = colorSet.every(color => color.usesAlias);

  if (withColorMode) {
    if (needsImport && importFileNames) {
      const importString = createImportStatementString({
        fileNames: importFileNames,
        extension: valueType,
        includeAs: needsImport && valueType === 'scss',
      });
      const colorVariablesString = stringWithColorMode(colorSet);
      return `${importString}
      ${colorVariablesString}
      `;
    }
    return stringWithColorMode(colorSet);
  } else {
    if (needsImport && importFileNames) {
      const importString = createImportStatementString({
        fileNames: importFileNames,
        extension: valueType,
        includeAs: needsImport && valueType === 'scss',
      });
      const colorVariablesString = stringWithoutColorMode(colorSet, needsRoot);
      return `${importString}
      ${colorVariablesString}
      `;
    }
    return stringWithoutColorMode(colorSet, needsRoot);
  }

  function stringWithColorMode(colorSet: variableSet[]) {
    const outputString = `
${WARNING_TEXT}
[data-color-mode='light'],
:root {
  ${colorSet
    .filter(color => color?.mode === 'light')
    .map(color => {
      const colorKey = color[keyType].key;
      const colorValue =
        keyType === 'css' && valueType === 'scss'
          ? color[valueType].sanitizedValue
          : color[valueType].value;
      return `${colorKey}: ${colorValue};`;
    })
    .join('\n  ')}
}

[data-color-mode='dark'] {
  ${colorSet
    .filter(color => color?.mode === 'dark')
    .map(color => {
      const colorKey = color[keyType].key;
      const colorValue =
        keyType === 'css' && valueType === 'scss'
          ? color[valueType].sanitizedValue
          : color[valueType].value;
      return `${colorKey}: ${colorValue};`;
    })
    .join('\n  ')}
}
`;

    return outputString;
  }
  function stringWithoutColorMode(colorSet: variableSet[], needsRoot: boolean) {
    const outputString = `
${WARNING_TEXT}
${needsRoot ? ':root {' : ''}
${needsRoot ? '\t' : ''}${colorSet
      .map(color => {
        const colorKey = color[keyType].key;
        const colorValue =
          keyType === 'css' && valueType === 'scss'
            ? color[valueType].sanitizedValue
            : color[valueType].value;
        return `${colorKey}: ${colorValue};`;
      })
      .join(`\n${needsRoot ? '\t' : ''}`)}
${needsRoot ? '}' : ''}
  `;
    return outputString;
  }
  function createImportStatementString({
    fileNames,
    extension,
    includeAs,
  }: {
    fileNames: string[];
    extension: 'css' | 'scss' | 'less';
    includeAs?: boolean;
  }) {
    const IMPORT_SYNTAX = { css: '@import', scss: '@use', less: '@import' };
    const asStatement = includeAs ? ' as *' : '';
    const importStatements = fileNames.map(fileName => {
      const importPath = `'@entur/tokens/dist/${fileName}.${extension}'`;
      return `${IMPORT_SYNTAX[extension]} ${importPath}${asStatement};`;
    });

    return importStatements.join('\n');
  }
}

export function outputColorsFiles({
  colorSet,
  keyType,
  valueType,
  name,
  toAllPackages = false,
  relativeOutputPath = 'dist',
}: {
  colorSet: variableSet[];
  keyType: 'css' | 'scss' | 'less';
  valueType: 'css' | 'scss' | 'less';
  name: string;
  toAllPackages?: boolean;
  relativeOutputPath?: string;
}) {
  let outputString = '';

  if (toAllPackages) {
    const packageNames = getAllPackageNames();
    packageNames.forEach(packageName => {
      outputString = '';
      const variablesForCurrentPackage = colorSet.filter(variable =>
        variable.scss.key.includes(`-${packageName}-`),
      );

      if (variablesForCurrentPackage.length === 0) {
        return;
      }

      if (packageName === 'travel') {
        outputString += createColorsOutputString({
          colorSet: variablesForCurrentPackage,
          keyType,
          valueType,
          withColorMode: true,
          importFileNames: ['semantic', 'transport'],
        });
      } else {
        outputString += createColorsOutputString({
          colorSet: variablesForCurrentPackage,
          keyType,
          valueType,
          withColorMode: true,
          importFileNames: ['semantic'],
        });
      }

      fs.outputFileSync(
        path.resolve(__dirname, '../../', packageName, 'src', `${name}.scss`),
        outputString,
      );
      return;
    });
    return;
  }

  switch (name) {
    case 'base':
      outputString += createColorsOutputString({
        colorSet,
        keyType,
        valueType,
        withColorMode: true,
        importFileNames: ['semantic', 'transport'],
      });
      break;
    case 'semantic':
      outputString += createColorsOutputString({
        colorSet,
        keyType,
        valueType,
        withColorMode: false,
        importFileNames: ['primitive'],
      });
      break;
    case 'data':
      outputString += createColorsOutputString({
        colorSet,
        keyType,
        valueType,
        withColorMode: true,
      });
      break;
    default:
      outputString += createColorsOutputString({
        colorSet,
        keyType,
        valueType,
        withColorMode: false,
      });
  }

  fs.outputFileSync(
    path.resolve(relativeOutputPath, `${name}.${valueType}`),
    outputString,
  );
}

function getAllPackageNames() {
  const packageNames = fs
    .readdirSync(path.resolve(__dirname, '../../../packages'), {
      withFileTypes: true,
    })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);

  return packageNames;
}

export function outputJSColorFile({
  variables,
  name,
  relativeOutputPath = '../src',
}: {
  variables: variableSet[];
  name: string;
  relativeOutputPath?: string;
}) {
  const jsVariables = variables.map(color => ({
    [color?.js.key]: color?.js.value,
  }));
  const jsVariablesObject = Object.assign({}, ...jsVariables);
  const unflattenedJSVariablesObject = unflatten(jsVariablesObject);

  const outputString = `${WARNING_TEXT}
 export const ${name} = ${JSON.stringify(unflattenedJSVariablesObject)}
 `;

  const formatedOutputString = prettier.format(outputString, {
    parser: 'babel',
  });

  fs.outputFileSync(
    path.resolve(__dirname, relativeOutputPath, `${name}.ts`),
    formatedOutputString,
  );
}

function toKebabCase(name: string) {
  return name.replace(/\//g, '-').replace(/\s/g, '').toLowerCase();
}

function toFlattenedJSObjectKey(name: string) {
  const nameWithoutSpacesAndDashes = name
    .toLowerCase()
    .replace(/\s(\w)/g, (_, letter) => letter.toUpperCase())
    .replace(/\-(\w)/g, (_, letter) => letter.toUpperCase());
  const nameArray = nameWithoutSpacesAndDashes.split('/');

  const nameArrayWithStringNumbers = nameArray.map(namePart => {
    if (!isNaN(Number(namePart.charAt(0)))) {
      return `_${namePart}`;
    }
    return namePart;
  });
  return nameArrayWithStringNumbers.join('.');
}
